
## 簡單工廠 + UML (p.02~22)

- 用活版印刷來解釋物件導向對變化的適應性
    1. 只想變更其中的幾個字  -> 可維護
    2. 印章之後還可以重複使用 -> 可複用
    3. 產品臨時要多加幾個字  -> 可擴展
    4. 水平排列變換成垂直排列 -> 靈活性好
- 簡單工廠這邊使用 Lisko 原則（子類必定實現父類的方法），當然也可將基礎類別改為 protocol 變成依賴於介面

```swift
// 基礎類別
class Operation {
    func getResult(_ num1: Double, _ num2: Double) -> Double { return 0 }
}
// 加法運算
class OperationAdd: Operation {
    override func getResult(num1: Double, num2: Double) { num1 + num2 }
}
// 簡單工廠
class OperationFactory {
    func create(_ operate: String) -> Operation {
        switch operate {
            case "+": 
                return OperationAdd()
            case "-": 
                return OperationSub()
            ...
        }
    }
}
```

- *介面* 與 *實作介面的類別* 使用空心三角形+虛線箭頭指向 **介面**（也可用棒棒糖標記法
- *祖先類別* 與 *子代類別* 使用空心三角形+實現箭頭指向 **祖先類別**
- *被依賴類別* 與 *依賴類別* 使用實心三角形+實現箭頭指向 **被依賴類別**

![](https://i.imgur.com/rEt5Y3v.jpg)


## 策略模式 Strategy Pattern (p.24~40)

> 類別的劃分是為了封裝，但分類的基礎是抽象，具有相同屬性和功能之物件的抽象集合才是類別。

- 特價是原價經折扣運算後的價格，所以折扣事實上就只是一種演算法
- 演算法可以把它想成是一種策略，不同策略可以套出不同的價格，聖誕節價格、週年慶價格...
- 重要的是這些演算法是隨時可替換的，這是變化點，是我們希望透過物件導向的多型來做動態替換的部分

```swift
protocol CashStrategy {
    func getNewPrice(origin: Double) -> Double
}
// 正常收費
class NormalStrategy: CashStrategy {
    func getNewPrice(origin: Double) -> Double { origin }
}
// 打九折、打八五折、打七折...
class RebateStrategy: CashStrategy {
    var rebateValue: Double
    func getNewPrice(origin: Double) -> Double { origin * rebateValue }
}
// 滿千送百、滿兩千送五百...
class AbcStrategy: CashStrategy {
    // TODO: ...
}
```

![](https://i.imgur.com/ILN5myH.jpg)


## 單一職責原則 Single Responsibility Pinciple (p.42~47)

> 就一個類別而言，應該僅有一個引起他變化的原因

- 我們設計程式時，很自然地會給一個類別加上各式各樣的功能，這意味無論任何需求要更改，都須要更改這個大雜燴類別。維護麻煩、複用不可能、沒有靈活性、改東壞西、生活一團糟 ~~（跟你的人生一樣）~~ 。
- 如果一個類別承擔的職責過多，就等於是把這些職責耦合在一起。當一個職責的變化可能會削弱或者抑制這個類別完成其他職責的能力，就是耦合過高導致脆弱的設計。
- 當變化發生時，會有意想不到的破壞。找出哪些是介面、哪些是遊戲邏輯，然後進行分離。
- 軟體設計這份工作真正要做的許多內容，就是去釐清職責並把那些不相干的職責相互分離。
- ~~如果你能想到多於一個的動機去改變一個類別，那麼這個類別就有多於一個職責。（這句話保留，太過執著於這一點會吵架）~~


## 開放封閉原則 Open-Close Pinciple (p.50~54)

- 面對新需求，對程式的改動是透過增加程式碼進行的，而不是更改現有的程式碼。
- 我們建立抽象來隔離以後可能發生的同類型變化（像是目前只有加減法，未來可能會有乘除法）。
- 這部分要注意的是：越晚察覺潛在的變化，要建立正確的抽象就越困難。
- 如果加減運算都在很多地方應用了，再來考慮抽象、考慮分離，就會很困難。


## 依賴倒轉原則 Dependency Inverse Pinciple (p.56~64)

- CPU 把介面定義好，其內部再複雜，只要插上符合規格的主機板就可以工作。
- Liskov 替換原則，也是一種依賴倒轉。
- 如果使用了一個父類別，那麼一定適用於其子類別，而且察覺不出父類別物件和子類別物件的區別；也就是說，把父類別都替換掉成它的子類別，程式的依然可以正常運作。
- 只有當子類別替換掉父類別，而軟體的功能不受影響時，父類別才能算是真正被複用（？）。


## 裝飾模式 Decorator Pattern (p.66~83)

- 客戶端程式碼可以在執行時根據需要，有選擇地、按順序地使用裝飾功能包裝物件。
- 保證裝飾類別之間彼此獨立，這樣它們就能以任意的順序進行組合。
- 一層包一層，下一層做完事情後，呼叫上一層做事（跟責任鏈有一點像）。


## 代理模式 Proxy Pattern (p.86~112)

> 為其他物件提供一種代理，以控制對這個物件的存取。

1. 遠端代理：隱藏客戶端真正實作的對象，故該對象的替換不會影響到客戶端。(strategy?)
2. 虛擬代理：需要建立消耗大量資源的情況下使用，用於存放實體化很長時間的情況。(flyweight?)
3. 安全代理：用於控制真實物件存取時的許可權。
4. 智慧參考：代理人可以多做一些事，客戶端都不會發現。

```swift
protocol IGiveGift {
    func giveDoll()
    func giveFlowers()
    func giveChocolate()
}

class Persuit: IGiveGift {
    var mm: SchoolGirl
    func giveDoll() { print(mm.name + "送你洋娃娃") }
    func giveFlowers() { print(mm.name + "送你鮮花") }
    func giveChocolate() { print(mm.name + "送你巧克力") }   
}

class Proxy: IGiveGift {
    var gg: IGiveGift   // gg 為職務代理人
    func giveDoll() { gg.giveDoll() }
    func giveFlowers() { gg.giveFlowers() }
    func giveChocolate() { gg.giveChocolate() }
}
```


## 工廠方法 Factory Method (p.100~112)

- 在本書中的介紹，「簡單工廠」與「工廠方法」為兩種不同的模式。
- 簡單工廠的特色：生產方法中會有一個 switch-case 做判斷，因產出的產品皆為父類別的子類別。
- 工廠方法的特色：在簡單工廠之上，將 switch-case 的判斷實作轉為客戶端履行。即客戶端需要先產生指定的工廠，並使用該工廠產生目標的產品，最後接續使用產品。
- 工廠方法對比簡單工廠的好處在於：不需要有一個大的簡單工廠做非常多的產品判斷，判斷的邏輯在客戶端實現，讓客戶端有更高的自主權。

```swift=
protocol IFactory {
    func create() -> Operation
}
class AddFactory: IFactory {
    func create() -> Operation { OperationAdd() }
}
class SubFactory: IFactory {
    func create() -> Operation { OperationSub() }
}
class MulFactory: IFactory {
    func create() -> Operation { OperationMul() }
}
class DivFactory: IFactory {
    func create() -> Operation { OperationDiv() }
}
func main() {
    let operFactory = AddFactory()
    let oper = operFactory.create()
    oper.numberA = 2
    oper.numberB = 3 
    let result = oper.getResult()    // result = 5
}
```


## 原型模式 Prototype Pattern (p.114~131)

- 實作 ICloneable 使物件可以做深拷貝，順便複習 pass by value, reference, 深拷貝, 淺拷貝。
- 這邊討論的實作都是深拷貝，即便是操作參考類型物件的拷貝品也不會影響到原物件的資料。
- 在 iOS 的世界，我們有 NSCopying。

```swift=
protocol ICloneable {
    func clone() -> Self
}
```


## 範本模式 Template Pattern (p.134~146)

- 重複 = 易錯 + 難改
- 利用繼承特性為子類別提供範本，透過覆寫來實現子類別的特定用途。
- 透過範本方法把這些行為搬移到單一的地方，幫助子類別擺脫重複的不便行為的糾纏。

```swift=
class AbstractClass {
    func primitiveOperation1() {
        // sub-class should override me
    }
    func primitiveOperation2() {
        // sub-class should override me
    }
    func tmeplateMethod() {
        self.primitiveOperation1()
        self.primitiveOperation2()
    }
}

class ConcreteClassA: AbstractClass {
    overried func primitiveOperation1() {
        print("具體類別Ａ 方法1 實現")
    }
    overried func primitiveOperation2() {
        print("具體類別Ａ 方法2 實現")
    }
}

class ConcreteClassB: AbstractClass {
    overried func primitiveOperation1() {
        print("具體類別B 方法1 實現")
    }
    overried func primitiveOperation2() {
        print("具體類別B 方法2 實現")
    }
}
```




