
## 簡單工廠 + UML (p.02~22)

- 用活版印刷來解釋物件導向對變化的適應性
    1. 只想變更其中的幾個字  -> 可維護
    2. 印章之後還可以重複使用 -> 可複用
    3. 產品臨時要多加幾個字  -> 可擴展
    4. 水平排列變換成垂直排列 -> 靈活性好
- 簡單工廠這邊使用 Lisko 原則（子類必定實現父類的方法），當然也可將基礎類別改為 protocol 變成依賴於介面

```swift
// 基礎類別
class Operation {
    func getResult(_ num1: Double, _ num2: Double) -> Double { return 0 }
}
// 加法運算
class OperationAdd: Operation {
    override func getResult(num1: Double, num2: Double) { num1 + num2 }
}
// 簡單工廠
class OperationFactory {
    func create(_ operate: String) -> Operation {
        switch operate {
            case "+": 
                return OperationAdd()
            case "-": 
                return OperationSub()
            ...
        }
    }
}
```

- *介面* 與 *實作介面的類別* 使用空心三角形+虛線箭頭指向 **介面**（也可用棒棒糖標記法
- *祖先類別* 與 *子代類別* 使用空心三角形+實現箭頭指向 **祖先類別**
- *被依賴類別* 與 *依賴類別* 使用實心三角形+實現箭頭指向 **被依賴類別**

![](https://i.imgur.com/rEt5Y3v.jpg)




## 策略模式 Strategy Pattern (p.24~40)

> 類別的劃分是為了封裝，但分類的基礎是抽象，具有相同屬性和功能之物件的抽象集合才是類別。

- 特價是原價經折扣運算後的價格，所以折扣事實上就只是一種演算法
- 演算法可以把它想成是一種策略，不同策略可以套出不同的價格，聖誕節價格、週年慶價格...
- 重要的是這些演算法是隨時可替換的，這是變化點，是我們希望透過物件導向的多型來做動態替換的部分

```swift=
protocol CashStrategy {
    func getNewPrice(origin: Double) -> Double
}
// 正常收費
class NormalStrategy: CashStrategy {
    func getNewPrice(origin: Double) -> Double { origin }
}
// 打九折、打八五折、打七折...
class RebateStrategy: CashStrategy {
    var rebateValue: Double
    func getNewPrice(origin: Double) -> Double { origin * rebateValue }
}
// 滿千送百、滿兩千送五百...
class AbcStrategy: CashStrategy {
    // TODO: ...
}
```

![](https://i.imgur.com/ILN5myH.jpg)




## 單一職責原則 Single Responsibility Pinciple (p.42~47)

> 就一個類別而言，應該僅有一個引起他變化的原因

- 我們設計程式時，很自然地會給一個類別加上各式各樣的功能，這意味無論任何需求要更改，都須要更改這個大雜燴類別。維護麻煩、複用不可能、沒有靈活性、改東壞西、生活一團糟 ~~（跟你的人生一樣）~~ 。
- 如果一個類別承擔的職責過多，就等於是把這些職責耦合在一起。當一個職責的變化可能會削弱或者抑制這個類別完成其他職責的能力，就是耦合過高導致脆弱的設計。
- 當變化發生時，會有意想不到的破壞。找出哪些是介面、哪些是遊戲邏輯，然後進行分離。
- 軟體設計這份工作真正要做的許多內容，就是去釐清職責並把那些不相干的職責相互分離。
- ~~如果你能想到多於一個的動機去改變一個類別，那麼這個類別就有多於一個職責。（這句話保留，太過執著於這一點會吵架）~~


## 開放封閉原則 Open-Close Pinciple (p.50~54)

- 面對新需求，對程式的改動是透過增加程式碼進行的，而不是更改現有的程式碼。
- 我們建立抽象來隔離以後可能發生的同類型變化（像是目前只有加減法，未來可能會有乘除法）。
- 這部分要注意的是：越晚察覺潛在的變化，要建立正確的抽象就越困難。
- 如果加減運算都在很多地方應用了，再來考慮抽象、考慮分離，就會很困難。


## 依賴倒轉原則 Dependency Inverse Pinciple (p.56~64)

- CPU 把介面定義好，其內部再複雜，只要插上符合規格的主機板就可以工作。
- Liskov 替換原則，也是一種依賴倒轉。
- 如果使用了一個父類別，那麼一定適用於其子類別，而且察覺不出父類別物件和子類別物件的區別；也就是說，把父類別都替換掉成它的子類別，程式的依然可以正常運作。
- 只有當子類別替換掉父類別，而軟體的功能不受影響時，父類別才能算是真正被複用（？）。










